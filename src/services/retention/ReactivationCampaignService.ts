import { Pool } from 'pg';
import { RetentionEngineRepository } from '../../repositories/RetentionEngineRepository';
import { TrafficManagerRepository } from '../../repositories/TrafficManagerRepository';
import { UserRepository } from '../../repositories/UserRepository';
import { BaseService } from '../base/BaseService';
import { 
  RetentionCampaign, 
  WinBackCampaign, 
  CampaignExecution,
  UserChurnRisk,
  UserLifecycleStage,
  CampaignAction,
  CampaignTrigger,
  CampaignPerformance
} from '../../models/RetentionEngine';
import { logger } from '../../config/logger';

export interface ReactivationCampaignConfig {
  name: string;
  description: string;
  targetSegment: 'at_risk' | 'churning' | 'churned' | 'inactive' | 'custom';
  triggerConditions: CampaignTrigger[];
  actions: CampaignAction[];
  escalationRules: EscalationRule[];
  budget: number;
  duration: number; // days
  cooldownPeriod: number; // hours
}

export interface EscalationRule {
  condition: 'no_response' | 'low_engagement' | 'time_based' | 'custom';
  timeThreshold: number; // hours
  action: 'increase_offer' | 'change_channel' | 'personal_outreach' | 'end_campaign';
  parameters: Record<string, any>;
}

export interface CampaignExecution {
  id: string;
  campaignId: string;
  userId: string;
  executionDate: Date;
  actionType: string;
  actionParameters: Record<string, any>;
  status: 'pending' | 'sent' | 'delivered' | 'opened' | 'clicked' | 'converted' | 'failed';
  responseData: Record<string, any>;
  cost: number;
  metadata: Record<string, any>;
  createdAt: Date;
  updatedAt: Date;
}

export class ReactivationCampaignService extends BaseService {
  private retentionRepo: RetentionEngineRepository;
  private trafficRepo: TrafficManagerRepository;
  private userRepo: UserRepository;

  constructor(pool: Pool) {
    super();
    this.retentionRepo = new RetentionEngineRepository(pool);
    this.trafficRepo = new TrafficManagerRepository(pool);
    this.userRepo = new UserRepository(pool);
  }

  // Create and launch reactivation campaign
  async createReactivationCampaign(config: ReactivationCampaignConfig): Promise<RetentionCampaign> {
    try {
      logger.info('Creating reactivation campaign', { name: config.name });

      // Validate configuration
      this.validateCampaignConfig(config);

      // Create campaign
      const campaign: Omit<RetentionCampaign, 'id' | 'createdAt' | 'updatedAt'> = {
        name: config.name,
        description: config.description,
        campaignType: 'reactive',
        status: 'draft',
        targetSegment: {
          segmentType: 'churn_risk',
          criteria: this.buildSegmentCriteria(config.targetSegment),
          estimatedSize: 0,
          refreshFrequency: 'daily'
        },
        triggers: config.triggerConditions,
        actions: config.actions,
        schedule: {
          scheduleType: 'immediate',
          timezone: 'Asia/Kolkata'
        },
        budget: {
          totalBudget: config.budget,
          currency: 'INR',
          spentAmount: 0,
          costPerAction: this.calculateCostPerAction(config.actions),
          budgetAllocation: [],
          alertThresholds: [50, 75, 90]
        },
        performance: {
          targetUsers: 0,
          reachedUsers: 0,
          engagedUsers: 0,
          convertedUsers: 0,
          reachRate: 0,
          engagementRate: 0,
          conversionRate: 0,
          costPerEngagement: 0,
          costPerConversion: 0,
          roi: 0,
          retentionImpact: 0,
          churnReduction: 0,
          revenueImpact: 0,
          metrics: {},
          lastUpdated: new Date()
        },
        startDate: new Date(),
        endDate: new Date(Date.now() + config.duration * 24 * 60 * 60 * 1000),
        createdBy: 'system',
        metadata: {
          escalationRules: config.escalationRules,
          cooldownPeriod: config.cooldownPeriod,
          autoGenerated: true
        }
      };

      const createdCampaign = await this.retentionRepo.createRetentionCampaign(campaign);

      // Activate campaign
      await this.activateCampaign(createdCampaign.id);

      logger.info('Reactivation campaign created successfully', { 
        campaignId: createdCampaign.id 
      });

      return createdCampaign;
    } catch (error) {
      logger.error('Error creating reactivation campaign', { error: error.message });
      throw error;
    }
  }

  // Execute campaign for eligible users
  async executeCampaign(campaignId: string): Promise<void> {
    try {
      logger.info('Executing reactivation campaign', { campaignId });

      const campaign = await this.retentionRepo.getActiveCampaigns()
        .then(campaigns => campaigns.find(c => c.id === campaignId));

      if (!campaign) {
        throw new Error(`Campaign not found: ${campaignId}`);
      }

      // Get eligible users
      const eligibleUsers = await this.getEligibleUsers(campaign);
      
      logger.info('Found eligible users for campaign', { 
        campaignId, 
        userCount: eligibleUsers.length 
      });

      // Execute actions for each user
      for (const user of eligibleUsers) {
        await this.executeUserActions(campaign, user);
      }

      // Update campaign performance
      await this.updateCampaignPerformance(campaignId, eligibleUsers.length);

    } catch (error) {
      logger.error('Error executing reactivation campaign', { 
        campaignId, 
        error: error.message 
      });
      throw error;
    }
  }

  // Send personalized reactivation message
  async sendReactivationMessage(userId: string, campaignId: string, messageConfig: any): Promise<void> {
    try {
      logger.info('Sending reactivation message', { userId, campaignId });

      // Get user data for personalization
      const user = await this.userRepo.findByTelegramId(userId);
      const churnRisk = await this.retentionRepo.getChurnRiskByUser(userId);
      
      if (!user) {
        throw new Error(`User not found: ${userId}`);
      }

      // Personalize message content
      const personalizedContent = await this.personalizeMessage(
        messageConfig.template, 
        user, 
        churnRisk
      );

      // Create campaign execution record
      const execution: Omit<CampaignExecution, 'id' | 'createdAt' | 'updatedAt'> = {
        campaignId,
        userId,
        executionDate: new Date(),
        actionType: 'send_message',
        actionParameters: {
          channel: messageConfig.channel || 'telegram',
          content: personalizedContent,
          template: messageConfig.template
        },
        status: 'pending',
        responseData: {},
        cost: messageConfig.cost || 0,
        metadata: {
          personalized: true,
          churnRiskScore: churnRisk?.churnRiskScore || 0
        }
      };

      // Record execution (would integrate with actual messaging service)
      logger.info('Reactivation message prepared', { 
        userId, 
        campaignId, 
        contentLength: personalizedContent.length 
      });

      // In a real implementation, this would send via Telegram API
      // For now, we'll just log the action
      await this.recordCampaignExecution(execution);

    } catch (error) {
      logger.error('Error sending reactivation message', { 
        userId, 
        campaignId, 
        error: error.message 
      });
      throw error;
    }
  }

  // Handle escalation based on user response
  async handleEscalation(campaignId: string, userId: string, escalationRule: EscalationRule): Promise<void> {
    try {
      logger.info('Handling campaign escalation', { campaignId, userId, rule: escalationRule.condition });

      switch (escalationRule.action) {
        case 'increase_offer':
          await this.increaseOffer(campaignId, userId, escalationRule.parameters);
          break;
        case 'change_channel':
          await this.changeChannel(campaignId, userId, escalationRule.parameters);
          break;
        case 'personal_outreach':
          await this.schedulePersonalOutreach(campaignId, userId, escalationRule.parameters);
          break;
        case 'end_campaign':
          await this.endUserCampaign(campaignId, userId);
          break;
      }

    } catch (error) {
      logger.error('Error handling escalation', { 
        campaignId, 
        userId, 
        error: error.message 
      });
      throw error;
    }
  }

  // Get campaign performance metrics
  async getCampaignPerformance(campaignId: string): Promise<CampaignPerformance> {
    try {
      const campaign = await this.retentionRepo.getActiveCampaigns()
        .then(campaigns => campaigns.find(c => c.id === campaignId));

      if (!campaign) {
        throw new Error(`Campaign not found: ${campaignId}`);
      }

      return campaign.performance;
    } catch (error) {
      logger.error('Error getting campaign performance', { campaignId, error: error.message });
      throw error;
    }
  }

  // Private helper methods
  private validateCampaignConfig(config: ReactivationCampaignConfig): void {
    if (!config.name || config.name.trim().length === 0) {
      throw new Error('Campaign name is required');
    }

    if (!config.actions || config.actions.length === 0) {
      throw new Error('At least one campaign action is required');
    }

    if (config.budget <= 0) {
      throw new Error('Campaign budget must be greater than 0');
    }

    if (config.duration <= 0) {
      throw new Error('Campaign duration must be greater than 0');
    }
  }

  private buildSegmentCriteria(targetSegment: string): any[] {
    switch (targetSegment) {
      case 'at_risk':
        return [
          { field: 'risk_level', operator: 'equals', value: 'high' },
          { field: 'days_since_last_activity', operator: 'greater_than', value: 7 }
        ];
      case 'churning':
        return [
          { field: 'risk_level', operator: 'equals', value: 'critical' },
          { field: 'days_since_last_activity', operator: 'greater_than', value: 14 }
        ];
      case 'churned':
        return [
          { field: 'current_stage', operator: 'equals', value: 'churned' },
          { field: 'days_since_last_activity', operator: 'greater_than', value: 30 }
        ];
      case 'inactive':
        return [
          { field: 'days_since_last_activity', operator: 'greater_than', value: 21 },
          { field: 'engagement_score', operator: 'less_than', value: 30 }
        ];
      default:
        return [];
    }
  }

  private calculateCostPerAction(actions: CampaignAction[]): number {
    // Simplified cost calculation
    return actions.reduce((total, action) => {
      switch (action.actionType) {
        case 'send_message': return total + 5;
        case 'send_offer': return total + 25;
        case 'schedule_followup': return total + 10;
        default: return total + 15;
      }
    }, 0);
  }

  private async activateCampaign(campaignId: string): Promise<void> {
    // Update campaign status to active
    logger.info('Activating campaign', { campaignId });
    // In a real implementation, this would update the database
  }

  private async getEligibleUsers(campaign: RetentionCampaign): Promise<UserChurnRisk[]> {
    // Get users matching campaign criteria
    const criteria = campaign.targetSegment.criteria;
    
    // For simplification, get high-risk users
    return await this.retentionRepo.getHighRiskUsers('high', 100);
  }

  private async executeUserActions(campaign: RetentionCampaign, user: UserChurnRisk): Promise<void> {
    for (const action of campaign.actions) {
      try {
        switch (action.actionType) {
          case 'send_message':
            await this.sendReactivationMessage(user.userId, campaign.id, action.parameters);
            break;
          case 'send_offer':
            await this.sendPersonalizedOffer(user.userId, campaign.id, action.parameters);
            break;
          case 'schedule_followup':
            await this.scheduleFollowup(user.userId, campaign.id, action.parameters);
            break;
        }
      } catch (error) {
        logger.error('Error executing user action', { 
          userId: user.userId, 
          actionType: action.actionType, 
          error: error.message 
        });
      }
    }
  }

  private async personalizeMessage(template: string, user: any, churnRisk: UserChurnRisk | null): Promise<string> {
    let content = template;
    
    // Replace placeholders with user data
    content = content.replace(/\{\{firstName\}\}/g, user.firstName || 'Valued Customer');
    content = content.replace(/\{\{lifetimeValue\}\}/g, churnRisk?.lifetimeValue?.toString() || '0');
    content = content.replace(/\{\{daysSinceLastActivity\}\}/g, churnRisk?.daysSinceLastActivity?.toString() || 'many');
    
    return content;
  }

  private async sendPersonalizedOffer(userId: string, campaignId: string, offerConfig: any): Promise<void> {
    logger.info('Sending personalized offer', { userId, campaignId });
    
    const execution: Omit<CampaignExecution, 'id' | 'createdAt' | 'updatedAt'> = {
      campaignId,
      userId,
      executionDate: new Date(),
      actionType: 'send_offer',
      actionParameters: offerConfig,
      status: 'pending',
      responseData: {},
      cost: offerConfig.cost || 25,
      metadata: { offerType: offerConfig.offerType }
    };

    await this.recordCampaignExecution(execution);
  }

  private async scheduleFollowup(userId: string, campaignId: string, followupConfig: any): Promise<void> {
    logger.info('Scheduling followup', { userId, campaignId });
    
    const execution: Omit<CampaignExecution, 'id' | 'createdAt' | 'updatedAt'> = {
      campaignId,
      userId,
      executionDate: new Date(Date.now() + (followupConfig.delay || 24) * 60 * 60 * 1000),
      actionType: 'schedule_followup',
      actionParameters: followupConfig,
      status: 'pending',
      responseData: {},
      cost: followupConfig.cost || 10,
      metadata: { followupType: followupConfig.followupType }
    };

    await this.recordCampaignExecution(execution);
  }

  private async recordCampaignExecution(execution: Omit<CampaignExecution, 'id' | 'createdAt' | 'updatedAt'>): Promise<void> {
    // In a real implementation, this would save to campaign_executions table
    logger.info('Campaign execution recorded', { 
      campaignId: execution.campaignId, 
      userId: execution.userId, 
      actionType: execution.actionType 
    });
  }

  private async updateCampaignPerformance(campaignId: string, targetUsers: number): Promise<void> {
    // Update campaign performance metrics
    const performance = {
      targetUsers,
      reachedUsers: targetUsers,
      engagedUsers: 0,
      convertedUsers: 0,
      reachRate: 100,
      engagementRate: 0,
      conversionRate: 0,
      costPerEngagement: 0,
      costPerConversion: 0,
      roi: 0,
      retentionImpact: 0,
      churnReduction: 0,
      revenueImpact: 0,
      metrics: {},
      lastUpdated: new Date()
    };

    await this.retentionRepo.updateCampaignPerformance(campaignId, performance);
  }

  private async increaseOffer(campaignId: string, userId: string, parameters: any): Promise<void> {
    logger.info('Increasing offer for user', { campaignId, userId });
    // Implementation would increase discount/offer value
  }

  private async changeChannel(campaignId: string, userId: string, parameters: any): Promise<void> {
    logger.info('Changing communication channel', { campaignId, userId });
    // Implementation would switch from telegram to email, etc.
  }

  private async schedulePersonalOutreach(campaignId: string, userId: string, parameters: any): Promise<void> {
    logger.info('Scheduling personal outreach', { campaignId, userId });
    // Implementation would schedule human intervention
  }

  private async endUserCampaign(campaignId: string, userId: string): Promise<void> {
    logger.info('Ending campaign for user', { campaignId, userId });
    // Implementation would mark user as campaign-ended
  }
}

export class ReactivationCampaignService extends BaseService {
  private retentionRepo: RetentionEngineRepository;
  private trafficRepo: TrafficManagerRepository;
  private userRepo: UserRepository;

  constructor(pool: Pool) {
    super();
    this.retentionRepo = new RetentionEngineRepository(pool);
    this.trafficRepo = new TrafficManagerRepository(pool);
    this.userRepo = new UserRepository(pool);
  }

  // Create and launch reactivation campaign
  async createReactivationCampaign(config: ReactivationCampaignConfig): Promise<RetentionCampaign> {
    try {
      logger.info('Creating reactivation campaign', { name: config.name });

      const campaign: Omit<RetentionCampaign, 'id' | 'createdAt' | 'updatedAt'> = {
        name: config.name,
        description: config.description,
        campaignType: 'reactive',
        status: 'draft',
        targetSegment: {
          segmentType: 'churn_risk',
          criteria: this.buildSegmentCriteria(config.targetSegment),
          estimatedSize: 0,
          refreshFrequency: 'daily'
        },
        triggers: config.triggerConditions,
        actions: config.actions,
        schedule: {
          scheduleType: 'immediate',
          timezone: 'Asia/Kolkata'
        },
        budget: {
          totalBudget: config.budget,
          currency: 'INR',
          spentAmount: 0,
          costPerAction: this.calculateCostPerAction(config.actions),
          budgetAllocation: this.allocateBudget(config.actions, config.budget),
          alertThresholds: [50, 75, 90]
        },
        performance: {
          targetUsers: 0,
          reachedUsers: 0,
          engagedUsers: 0,
          convertedUsers: 0,
          reachRate: 0,
          engagementRate: 0,
          conversionRate: 0,
          costPerEngagement: 0,
          costPerConversion: 0,
          roi: 0,
          retentionImpact: 0,
          churnReduction: 0,
          revenueImpact: 0,
          metrics: {},
          lastUpdated: new Date()
        },
        startDate: new Date(),
        endDate: new Date(Date.now() + config.duration * 24 * 60 * 60 * 1000),
        createdBy: 'system',
        metadata: {
          escalationRules: config.escalationRules,
          cooldownPeriod: config.cooldownPeriod,
          autoGenerated: true
        }
      };

      const createdCampaign = await this.retentionRepo.createRetentionCampaign(campaign);
      
      logger.info('Reactivation campaign created', { 
        campaignId: createdCampaign.id,
        name: config.name 
      });

      return createdCampaign;
    } catch (error) {
      logger.error('Error creating reactivation campaign', { 
        name: config.name, 
        error: error.message 
      });
      throw error;
    }
  }
} 
 // Execute campaign for eligible users
  async executeCampaign(campaignId: string): Promise<void> {
    try {
      logger.info('Executing reactivation campaign', { campaignId });

      const campaign = await this.retentionRepo.getActiveCampaigns();
      const targetCampaign = campaign.find(c => c.id === campaignId);
      
      if (!targetCampaign) {
        throw new Error(`Campaign not found: ${campaignId}`);
      }

      // Get eligible users based on segment criteria
      const eligibleUsers = await this.getEligibleUsers(targetCampaign);
      
      logger.info('Found eligible users for campaign', { 
        campaignId, 
        userCount: eligibleUsers.length 
      });

      // Execute actions for each user
      const executions: Promise<void>[] = [];
      for (const user of eligibleUsers) {
        executions.push(this.executeUserActions(targetCampaign, user));
      }

      await Promise.all(executions);

      // Update campaign performance
      await this.updateCampaignPerformance(campaignId, eligibleUsers.length);

      logger.info('Campaign execution completed', { 
        campaignId, 
        processedUsers: eligibleUsers.length 
      });

    } catch (error) {
      logger.error('Error executing campaign', { campaignId, error: error.message });
      throw error;
    }
  }

  // Execute actions for a specific user
  private async executeUserActions(campaign: RetentionCampaign, user: UserChurnRisk): Promise<void> {
    try {
      for (const action of campaign.actions) {
        await this.executeAction(campaign.id, user.userId, action);
        
        // Add delay between actions if specified
        if (action.delay && action.delay > 0) {
          await this.scheduleDelayedAction(campaign.id, user.userId, action, action.delay);
        }
      }
    } catch (error) {
      logger.error('Error executing user actions', { 
        campaignId: campaign.id, 
        userId: user.userId, 
        error: error.message 
      });
    }
  }

  // Execute individual action
  private async executeAction(campaignId: string, userId: string, action: CampaignAction): Promise<void> {
    try {
      const execution: Omit<CampaignExecution, 'id' | 'createdAt' | 'updatedAt'> = {
        campaignId,
        userId,
        executionDate: new Date(),
        actionType: action.actionType,
        actionParameters: action.parameters,
        status: 'pending',
        responseData: {},
        cost: this.calculateActionCost(action),
        metadata: {
          actionId: `${campaignId}_${userId}_${Date.now()}`,
          retryCount: 0
        }
      };

      switch (action.actionType) {
        case 'send_message':
          await this.sendMessage(execution);
          break;
        case 'send_offer':
          await this.sendOffer(execution);
          break;
        case 'assign_tag':
          await this.assignTag(execution);
          break;
        case 'trigger_webhook':
          await this.triggerWebhook(execution);
          break;
        case 'schedule_followup':
          await this.scheduleFollowup(execution);
          break;
        default:
          logger.warn('Unknown action type', { actionType: action.actionType });
      }

      logger.info('Action executed successfully', { 
        campaignId, 
        userId, 
        actionType: action.actionType 
      });

    } catch (error) {
      logger.error('Error executing action', { 
        campaignId, 
        userId, 
        actionType: action.actionType, 
        error: error.message 
      });
    }
  }

  // Send personalized message
  private async sendMessage(execution: Omit<CampaignExecution, 'id' | 'createdAt' | 'updatedAt'>): Promise<void> {
    try {
      const { channel, template, content, offerDetails } = execution.actionParameters;
      
      // Get user data for personalization
      const user = await this.userRepo.findByTelegramId(execution.userId);
      if (!user) {
        throw new Error(`User not found: ${execution.userId}`);
      }

      // Personalize message content
      const personalizedContent = await this.personalizeContent(content, user, offerDetails);
      
      // Send message based on channel
      switch (channel) {
        case 'telegram':
          await this.sendTelegramMessage(user.telegramId, personalizedContent);
          break;
        case 'email':
          await this.sendEmailMessage(user.email, personalizedContent);
          break;
        default:
          throw new Error(`Unsupported channel: ${channel}`);
      }

      execution.status = 'sent';
      execution.responseData = {
        channel,
        messageLength: personalizedContent.length,
        sentAt: new Date()
      };

    } catch (error) {
      execution.status = 'failed';
      execution.responseData = { error: error.message };
      throw error;
    }
  }

  // Send personalized offer
  private async sendOffer(execution: Omit<CampaignExecution, 'id' | 'createdAt' | 'updatedAt'>): Promise<void> {
    try {
      const { offerType, value, description, validityPeriod, conditions } = execution.actionParameters;
      
      // Create personalized offer
      const offer = {
        type: offerType,
        value,
        description,
        validUntil: new Date(Date.now() + validityPeriod * 24 * 60 * 60 * 1000),
        conditions,
        userId: execution.userId,
        campaignId: execution.campaignId
      };

      // Generate offer code
      const offerCode = this.generateOfferCode(execution.userId, execution.campaignId);
      
      // Send offer message
      const offerMessage = this.formatOfferMessage(offer, offerCode);
      await this.sendTelegramMessage(execution.userId, offerMessage);

      execution.status = 'sent';
      execution.responseData = {
        offerCode,
        offerType,
        value,
        validUntil: offer.validUntil
      };

    } catch (error) {
      execution.status = 'failed';
      execution.responseData = { error: error.message };
      throw error;
    }
  }

  // Get eligible users for campaign
  private async getEligibleUsers(campaign: RetentionCampaign): Promise<UserChurnRisk[]> {
    try {
      const { segmentType, criteria } = campaign.targetSegment;
      
      switch (segmentType) {
        case 'churn_risk':
          return await this.getUsersByChurnRisk(criteria);
        case 'lifecycle_stage':
          return await this.getUsersByLifecycleStage(criteria);
        case 'activity_level':
          return await this.getUsersByActivityLevel(criteria);
        default:
          return await this.getUsersByCustomCriteria(criteria);
      }
    } catch (error) {
      logger.error('Error getting eligible users', { 
        campaignId: campaign.id, 
        error: error.message 
      });
      return [];
    }
  }

  // Get users by churn risk criteria
  private async getUsersByChurnRisk(criteria: any[]): Promise<UserChurnRisk[]> {
    const users: UserChurnRisk[] = [];
    
    for (const criterion of criteria) {
      switch (criterion.field) {
        case 'risk_level':
          const riskUsers = await this.retentionRepo.getHighRiskUsers(criterion.value, 1000);
          users.push(...riskUsers);
          break;
        case 'churn_risk_score':
          // Would implement score-based filtering
          break;
        case 'days_since_last_activity':
          // Would implement activity-based filtering
          break;
      }
    }

    return this.deduplicateUsers(users);
  }

  // Personalize content for user
  private async personalizeContent(content: string, user: any, offerDetails?: any): Promise<string> {
    let personalizedContent = content;

    // Replace user placeholders
    personalizedContent = personalizedContent.replace(/\{\{firstName\}\}/g, user.firstName || 'Friend');
    personalizedContent = personalizedContent.replace(/\{\{username\}\}/g, user.username || 'there');

    // Replace offer placeholders
    if (offerDetails) {
      personalizedContent = personalizedContent.replace(/\{\{discount\}\}/g, offerDetails.value || '10');
      personalizedContent = personalizedContent.replace(/\{\{validUntil\}\}/g, 
        offerDetails.validUntil ? new Date(offerDetails.validUntil).toLocaleDateString() : '7 days');
    }

    // Add personalized product recommendations
    const recommendations = await this.getPersonalizedRecommendations(user.telegramId);
    if (recommendations.length > 0) {
      const productList = recommendations.slice(0, 3).map(p => `‚Ä¢ ${p.name}`).join('\n');
      personalizedContent += `\n\nRecommended for you:\n${productList}`;
    }

    return personalizedContent;
  }

  // Send Telegram message
  private async sendTelegramMessage(userId: string, content: string): Promise<void> {
    // This would integrate with TelegramBotService
    logger.info('Sending Telegram message', { userId, contentLength: content.length });
    
    // Mock implementation - in production would use actual Telegram API
    await new Promise(resolve => setTimeout(resolve, 100));
  }

  // Generate offer code
  private generateOfferCode(userId: string, campaignId: string): string {
    const timestamp = Date.now().toString(36);
    const userHash = userId.slice(-4);
    const campaignHash = campaignId.slice(-4);
    return `REACTIVATE_${userHash}_${campaignHash}_${timestamp}`.toUpperCase();
  }

  // Format offer message
  private formatOfferMessage(offer: any, offerCode: string): string {
    return `üéâ Special Offer Just for You!

${offer.description}

üí∞ ${offer.type === 'percentage_discount' ? offer.value + '% OFF' : '‚Çπ' + offer.value + ' OFF'}
‚è∞ Valid until: ${offer.validUntil.toLocaleDateString()}
üé´ Code: ${offerCode}

Tap here to claim your offer! üëÜ`;
  }

  // Get personalized recommendations
  private async getPersonalizedRecommendations(userId: string): Promise<any[]> {
    // Mock implementation - would integrate with RecommendationService
    return [
      { name: 'iPhone 15 Pro', category: 'Electronics' },
      { name: 'Nike Air Max', category: 'Fashion' },
      { name: 'Coffee Maker', category: 'Home & Kitchen' }
    ];
  }

  // Helper methods
  private buildSegmentCriteria(targetSegment: string): any[] {
    switch (targetSegment) {
      case 'at_risk':
        return [
          { field: 'risk_level', operator: 'equals', value: 'medium' },
          { field: 'days_since_last_activity', operator: 'greater_than', value: 7 }
        ];
      case 'churning':
        return [
          { field: 'risk_level', operator: 'in', value: ['high', 'critical'] },
          { field: 'days_since_last_activity', operator: 'greater_than', value: 14 }
        ];
      case 'churned':
        return [
          { field: 'days_since_last_activity', operator: 'greater_than', value: 30 }
        ];
      case 'inactive':
        return [
          { field: 'days_since_last_activity', operator: 'greater_than', value: 21 }
        ];
      default:
        return [];
    }
  }

  private calculateCostPerAction(actions: CampaignAction[]): number {
    const totalCost = actions.reduce((sum, action) => {
      return sum + this.calculateActionCost(action);
    }, 0);
    return totalCost / actions.length;
  }

  private calculateActionCost(action: CampaignAction): number {
    switch (action.actionType) {
      case 'send_message':
        return action.parameters.channel === 'telegram' ? 0.5 : 2.0;
      case 'send_offer':
        return action.parameters.offerDetails?.value || 50;
      case 'assign_tag':
        return 0.1;
      case 'trigger_webhook':
        return 1.0;
      case 'schedule_followup':
        return 0.5;
      default:
        return 1.0;
    }
  }

  private allocateBudget(actions: CampaignAction[], totalBudget: number): any[] {
    const actionCosts = actions.map(action => ({
      category: action.actionType,
      cost: this.calculateActionCost(action)
    }));

    const totalCost = actionCosts.reduce((sum, item) => sum + item.cost, 0);
    
    return actionCosts.map(item => ({
      category: item.category,
      allocatedAmount: (item.cost / totalCost) * totalBudget,
      spentAmount: 0,
      percentage: (item.cost / totalCost) * 100
    }));
  }

  private deduplicateUsers(users: UserChurnRisk[]): UserChurnRisk[] {
    const seen = new Set();
    return users.filter(user => {
      if (seen.has(user.userId)) {
        return false;
      }
      seen.add(user.userId);
      return true;
    });
  }

  private async getUsersByLifecycleStage(criteria: any[]): Promise<UserChurnRisk[]> {
    // Mock implementation
    return [];
  }

  private async getUsersByActivityLevel(criteria: any[]): Promise<UserChurnRisk[]> {
    // Mock implementation
    return [];
  }

  private async getUsersByCustomCriteria(criteria: any[]): Promise<UserChurnRisk[]> {
    // Mock implementation
    return [];
  }

  private async assignTag(execution: Omit<CampaignExecution, 'id' | 'createdAt' | 'updatedAt'>): Promise<void> {
    // Mock implementation
    execution.status = 'sent';
  }

  private async triggerWebhook(execution: Omit<CampaignExecution, 'id' | 'createdAt' | 'updatedAt'>): Promise<void> {
    // Mock implementation
    execution.status = 'sent';
  }

  private async scheduleFollowup(execution: Omit<CampaignExecution, 'id' | 'createdAt' | 'updatedAt'>): Promise<void> {
    // Mock implementation
    execution.status = 'sent';
  }

  private async scheduleDelayedAction(campaignId: string, userId: string, action: CampaignAction, delay: number): Promise<void> {
    // Mock implementation - would use job queue
    logger.info('Scheduling delayed action', { campaignId, userId, delay });
  }

  private async sendEmailMessage(email: string, content: string): Promise<void> {
    // Mock implementation
    logger.info('Sending email message', { email, contentLength: content.length });
  }

  private async updateCampaignPerformance(campaignId: string, processedUsers: number): Promise<void> {
    // Mock implementation
    logger.info('Updating campaign performance', { campaignId, processedUsers });
  }
}