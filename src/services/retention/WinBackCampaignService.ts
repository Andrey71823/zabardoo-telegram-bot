import { Pool } from 'pg';
import { RetentionEngineRepository } from '../../repositories/RetentionEngineRepository';
import { TrafficManagerRepository } from '../../repositories/TrafficManagerRepository';
import { UserRepository } from '../../repositories/UserRepository';
import { BaseService } from '../base/BaseService';
import { 
  WinBackCampaign, 
  WinBackStrategy, 
  WinBackPhase, 
  WinBackOffer, 
  WinBackTouchpoint,
  WinBackPerformance,
  UserChurnRisk
} from '../../models/RetentionEngine';
import { logger } from '../../config/logger';

export interface WinBackCampaignConfig {
  name: string;
  description: string;
  targetSegment: 'recently_churned' | 'long_term_churned' | 'high_value_churned' | 'custom';
  churnTimeframeDays: number;
  strategy: WinBackStrategyConfig;
  budget: number;
  duration: number; // days
}

export interface WinBackStrategyConfig {
  strategyType: 'aggressive_discount' | 'personalized_offer' | 'content_engagement' | 'social_proof' | 'multi_touch';
  phases: WinBackPhaseConfig[];
  escalationThreshold: number; // percentage
  maxOfferValue: number;
}

export interface WinBackPhaseConfig {
  name: string;
  duration: number; // days
  offerType: 'percentage_discount' | 'fixed_discount' | 'cashback' | 'free_product' | 'exclusive_access';
  offerValue: number;
  messageTemplate: string;
  successThreshold: number; // percentage
}

export class WinBackCampaignService extends BaseService {
  private retentionRepo: RetentionEngineRepository;
  private trafficRepo: TrafficManagerRepository;
  private userRepo: UserRepository;

  constructor(pool: Pool) {
    super();
    this.retentionRepo = new RetentionEngineRepository(pool);
    this.trafficRepo = new TrafficManagerRepository(pool);
    this.userRepo = new UserRepository(pool);
  }

  // Create win-back campaign
  async createWinBackCampaign(config: WinBackCampaignConfig): Promise<WinBackCampaign> {
    try {
      logger.info('Creating win-back campaign', { name: config.name });

      const campaign: Omit<WinBackCampaign, 'id' | 'createdAt' | 'updatedAt'> = {
        name: config.name,
        description: config.description,
        targetSegment: config.targetSegment,
        churnTimeframe: {
          startDate: new Date(Date.now() - config.churnTimeframeDays * 24 * 60 * 60 * 1000),
          endDate: new Date(),
          preset: 'custom'
        },
        winBackStrategy: this.buildWinBackStrategy(config.strategy),
        offers: this.buildWinBackOffers(config.strategy.phases),
        touchpoints: this.buildWinBackTouchpoints(config.strategy.phases),
        performance: this.initializePerformance(),
        budget: config.budget,
        status: 'draft',
        startDate: new Date(),
        endDate: new Date(Date.now() + config.duration * 24 * 60 * 60 * 1000),
        metadata: {
          autoGenerated: true,
          configUsed: config
        }
      };

      const createdCampaign = await this.retentionRepo.createWinBackCampaign(campaign);
      
      logger.info('Win-back campaign created', { 
        campaignId: createdCampaign.id,
        name: config.name 
      });

      return createdCampaign;
    } catch (error) {
      logger.error('Error creating win-back campaign', { 
        name: config.name, 
        error: error.message 
      });
      throw error;
    }
  }

  // Execute win-back campaign
  async executeWinBackCampaign(campaignId: string): Promise<void> {
    try {
      logger.info('Executing win-back campaign', { campaignId });

      const campaigns = await this.retentionRepo.getActiveWinBackCampaigns();
      const campaign = campaigns.find(c => c.id === campaignId);
      
      if (!campaign) {
        throw new Error(`Win-back campaign not found: ${campaignId}`);
      }

      // Get churned users based on target segment
      const churnedUsers = await this.getChurnedUsers(campaign);
      
      logger.info('Found churned users for win-back', { 
        campaignId, 
        userCount: churnedUsers.length 
      });

      // Execute win-back strategy for each user
      for (const user of churnedUsers) {
        await this.executeWinBackStrategy(campaign, user);
      }

      // Update campaign performance
      await this.updateWinBackPerformance(campaignId, churnedUsers.length);

      logger.info('Win-back campaign execution completed', { 
        campaignId, 
        processedUsers: churnedUsers.length 
      });

    } catch (error) {
      logger.error('Error executing win-back campaign', { 
        campaignId, 
        error: error.message 
      });
      throw error;
    }
  }

  // Execute win-back strategy for individual user
  private async executeWinBackStrategy(campaign: WinBackCampaign, user: any): Promise<void> {
    try {
      const { phases } = campaign.winBackStrategy;
      
      for (let i = 0; i < phases.length; i++) {
        const phase = phases[i];
        const success = await this.executeWinBackPhase(campaign, user, phase, i + 1);
        
        if (success) {
          logger.info('User reactivated in phase', { 
            campaignId: campaign.id, 
            userId: user.userId, 
            phase: i + 1 
          });
          break; // User reactivated, no need to continue
        }
        
        // Wait for phase duration before next phase
        if (i < phases.length - 1) {
          await this.scheduleNextPhase(campaign.id, user.userId, phases[i + 1], phase.duration);
        }
      }
    } catch (error) {
      logger.error('Error executing win-back strategy', { 
        campaignId: campaign.id, 
        userId: user.userId, 
        error: error.message 
      });
    }
  }

  // Execute individual win-back phase
  private async executeWinBackPhase(
    campaign: WinBackCampaign, 
    user: any, 
    phase: any, 
    phaseNumber: number
  ): Promise<boolean> {
    try {
      logger.info('Executing win-back phase', { 
        campaignId: campaign.id, 
        userId: user.userId, 
        phase: phaseNumber 
      });

      // Find corresponding offer and touchpoint
      const offer = campaign.offers.find(o => o.offerType === phase.offerType);
      const touchpoint = campaign.touchpoints.find(t => t.timing === (phaseNumber - 1));
      
      if (!offer || !touchpoint) {
        logger.warn('Missing offer or touchpoint for phase', { 
          campaignId: campaign.id, 
          phase: phaseNumber 
        });
        return false;
      }

      // Personalize offer for user
      const personalizedOffer = await this.personalizeWinBackOffer(offer, user);
      
      // Send win-back message
      await this.sendWinBackMessage(user, touchpoint, personalizedOffer);
      
      // Track phase execution
      await this.trackPhaseExecution(campaign.id, user.userId, phaseNumber, personalizedOffer);
      
      // Check if user responded positively (mock implementation)
      const responded = await this.checkUserResponse(user.userId, phase.duration);
      
      return responded;
    } catch (error) {
      logger.error('Error executing win-back phase', { 
        campaignId: campaign.id, 
        userId: user.userId, 
        phase: phaseNumber, 
        error: error.message 
      });
      return false;
    }
  }

  // Get churned users based on campaign target segment
  private async getChurnedUsers(campaign: WinBackCampaign): Promise<any[]> {
    try {
      const { targetSegment, churnTimeframe } = campaign;
      
      switch (targetSegment) {
        case 'recently_churned':
          return await this.getRecentlyChurnedUsers(churnTimeframe);
        case 'long_term_churned':
          return await this.getLongTermChurnedUsers(churnTimeframe);
        case 'high_value_churned':
          return await this.getHighValueChurnedUsers(churnTimeframe);
        default:
          return await this.getCustomChurnedUsers(campaign);
      }
    } catch (error) {
      logger.error('Error getting churned users', { 
        campaignId: campaign.id, 
        error: error.message 
      });
      return [];
    }
  }

  // Get recently churned users (churned in last 30 days)
  private async getRecentlyChurnedUsers(timeframe: any): Promise<any[]> {
    // Mock implementation - would query actual churned users
    return [
      {
        userId: 'churned-user-1',
        churnDate: new Date(Date.now() - 15 * 24 * 60 * 60 * 1000),
        lifetimeValue: 2500,
        lastPurchaseCategory: 'electronics',
        churnReason: 'inactivity'
      },
      {
        userId: 'churned-user-2',
        churnDate: new Date(Date.now() - 25 * 24 * 60 * 60 * 1000),
        lifetimeValue: 1800,
        lastPurchaseCategory: 'fashion',
        churnReason: 'competitor_switch'
      }
    ];
  }

  // Personalize win-back offer for user
  private async personalizeWinBackOffer(offer: WinBackOffer, user: any): Promise<WinBackOffer> {
    const personalizedOffer = { ...offer };

    // Adjust offer value based on user's lifetime value
    if (user.lifetimeValue > 5000) {
      personalizedOffer.value = Math.min(offer.value * 1.5, 50); // Max 50% discount
    } else if (user.lifetimeValue < 1000) {
      personalizedOffer.value = Math.max(offer.value * 0.8, 10); // Min 10% discount
    }

    // Personalize description
    personalizedOffer.description = personalizedOffer.description
      .replace('{{userName}}', user.firstName || 'Friend')
      .replace('{{lastCategory}}', user.lastPurchaseCategory || 'your favorites');

    // Add personalized elements
    personalizedOffer.personalizedElements = [
      {
        elementType: 'product_recommendation',
        personalizationLogic: `Based on your previous ${user.lastPurchaseCategory} purchases`,
        fallbackValue: 'trending products'
      },
      {
        elementType: 'discount_amount',
        personalizationLogic: `Special ${personalizedOffer.value}% discount just for you`,
        fallbackValue: `${offer.value}% discount`
      }
    ];

    return personalizedOffer;
  }

  // Send win-back message to user
  private async sendWinBackMessage(
    user: any, 
    touchpoint: WinBackTouchpoint, 
    offer: WinBackOffer
  ): Promise<void> {
    try {
      const message = this.formatWinBackMessage(touchpoint.content, offer, user);
      
      switch (touchpoint.touchpointType) {
        case 'telegram':
          await this.sendTelegramWinBackMessage(user.userId, message);
          break;
        case 'email':
          await this.sendEmailWinBackMessage(user.email, message);
          break;
        default:
          logger.warn('Unsupported touchpoint type', { 
            type: touchpoint.touchpointType 
          });
      }

      logger.info('Win-back message sent', { 
        userId: user.userId, 
        touchpointType: touchpoint.touchpointType 
      });

    } catch (error) {
      logger.error('Error sending win-back message', { 
        userId: user.userId, 
        error: error.message 
      });
      throw error;
    }
  }

  // Format win-back message
  private formatWinBackMessage(content: any, offer: WinBackOffer, user: any): string {
    let message = content.headline + '\n\n' + content.body + '\n\n';
    
    // Add offer details
    message += `🎁 Special Offer: ${offer.description}\n`;
    message += `💰 ${offer.offerType === 'percentage_discount' ? offer.value + '% OFF' : '₹' + offer.value + ' OFF'}\n`;
    message += `⏰ Valid for ${offer.validityPeriod} days\n`;
    message += `🎫 Use code: WINBACK${user.userId.slice(-4).toUpperCase()}\n\n`;
    
    // Add call to action
    message += content.callToAction;
    
    // Add personalized recommendations if available
    if (offer.personalizedElements && offer.personalizedElements.length > 0) {
      const productRec = offer.personalizedElements.find(e => e.elementType === 'product_recommendation');
      if (productRec) {
        message += `\n\n${productRec.personalizationLogic}`;
      }
    }

    return message;
  }

  // Build win-back strategy from config
  private buildWinBackStrategy(config: WinBackStrategyConfig): WinBackStrategy {
    return {
      strategyType: config.strategyType,
      phases: config.phases.map((phase, index) => ({
        phaseNumber: index + 1,
        name: phase.name,
        duration: phase.duration,
        actions: [
          {
            actionType: 'send_message',
            parameters: {
              channel: 'telegram',
              template: phase.messageTemplate,
              offerDetails: {
                offerType: phase.offerType,
                value: phase.offerValue
              }
            }
          }
        ],
        successThreshold: phase.successThreshold,
        failureAction: index < config.phases.length - 1 ? 'escalate' : 'end'
      })),
      escalationRules: [
        {
          condition: 'no_response_7_days',
          action: 'increase_offer',
          parameters: { 
            maxIncrease: config.maxOfferValue,
            increasePercentage: 25 
          }
        }
      ],
      successCriteria: {
        primaryMetric: 'reactivation_rate',
        targetValue: config.escalationThreshold,
        timeframe: config.phases.reduce((sum, p) => sum + p.duration, 0),
        minimumSampleSize: 50
      }
    };
  }

  // Build win-back offers from phases
  private buildWinBackOffers(phases: WinBackPhaseConfig[]): WinBackOffer[] {
    return phases.map(phase => ({
      offerType: phase.offerType,
      value: phase.offerValue,
      description: `Exclusive ${phase.offerValue}${phase.offerType === 'percentage_discount' ? '%' : '₹'} ${phase.offerType.replace('_', ' ')} for {{userName}}`,
      validityPeriod: phase.duration,
      usageLimit: 1,
      conditions: ['minimum_order_500'],
      personalizedElements: []
    }));
  }

  // Build win-back touchpoints from phases
  private buildWinBackTouchpoints(phases: WinBackPhaseConfig[]): WinBackTouchpoint[] {
    return phases.map((phase, index) => ({
      touchpointType: 'telegram',
      timing: index,
      content: {
        headline: index === 0 ? 'We Miss You!' : `Last Chance - ${phase.name}`,
        body: `Come back and enjoy our special ${phase.offerType.replace('_', ' ')} offer.`,
        callToAction: 'Claim Your Offer Now! 👆',
        visualElements: []
      },
      personalization: [
        {
          elementType: 'message_content',
          personalizationLogic: 'user_history_based',
          fallbackValue: 'generic_message'
        }
      ]
    }));
  }

  // Initialize performance metrics
  private initializePerformance(): WinBackPerformance {
    return {
      targetUsers: 0,
      contactedUsers: 0,
      reactivatedUsers: 0,
      reactivationRate: 0,
      revenueRecovered: 0,
      averageRevenuePerReactivation: 0,
      costPerReactivation: 0,
      roi: 0,
      touchpointPerformance: {},
      phasePerformance: {},
      timeToReactivation: 0
    };
  }

  // Helper methods (mock implementations)
  private async getLongTermChurnedUsers(timeframe: any): Promise<any[]> {
    return [];
  }

  private async getHighValueChurnedUsers(timeframe: any): Promise<any[]> {
    return [];
  }

  private async getCustomChurnedUsers(campaign: WinBackCampaign): Promise<any[]> {
    return [];
  }

  private async scheduleNextPhase(campaignId: string, userId: string, nextPhase: any, delay: number): Promise<void> {
    logger.info('Scheduling next win-back phase', { campaignId, userId, delay });
  }

  private async trackPhaseExecution(campaignId: string, userId: string, phase: number, offer: WinBackOffer): Promise<void> {
    logger.info('Tracking phase execution', { campaignId, userId, phase });
  }

  private async checkUserResponse(userId: string, duration: number): Promise<boolean> {
    // Mock implementation - would check actual user activity
    return Math.random() > 0.7; // 30% success rate
  }

  private async sendTelegramWinBackMessage(userId: string, message: string): Promise<void> {
    logger.info('Sending Telegram win-back message', { userId, messageLength: message.length });
  }

  private async sendEmailWinBackMessage(email: string, message: string): Promise<void> {
    logger.info('Sending email win-back message', { email, messageLength: message.length });
  }

  private async updateWinBackPerformance(campaignId: string, processedUsers: number): Promise<void> {
    logger.info('Updating win-back performance', { campaignId, processedUsers });
  }
}